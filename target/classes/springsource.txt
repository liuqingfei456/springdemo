spring容器的refresh()[创建刷新]
1。prepareRefresh();刷新前的预处理工作；
    1).initPropertySources()初始化一些占位符属性设置；子类自定义个性化的属性设置方法
    2).getEnvironment().validateRequiredProperties();检验属性的合法等
    3).this.earlyApplicationListeners = new LinkedHashSet<>(this.applicationListeners);保存容器中一些早期的事件；
2。obtainFreshBeanFactory()；获取并刷新BeanFactory；
    1).refreshBeanFactory();刷新BeanFactory;
          创建了一个this.beanFactory = new DefaultListableBeanFactory();
          设置id；
    2).getBeanFactory();返回刚才GenericApplicationContext创建的BeanFactory对象
    3).将创建的BeanFactory【DefaultListableBeanFactory】返回；
3。prepareBeanFactory(beanFactory);BeanFactory的预准备工作(BeanFactory进行一些设置)；
    1).设置BeanFactory的类加载器、支持表达式解析器等等。。。
    2).添加部分BeanPostProcessor【ApplicationContextAwareProcessor】
    3).设置忽略的自动装配的接口EnvironmentAware、EmbeddedValueResolverAware、xxx
    4).注册可解析的自动装配；我们可能直接在任何组件中自动注入；
            BeanFactory、ResourceLoader、ApplicationEventPublisher、ApplicationContext
    5).添加BeanPostProcessor【ApplicationListenerDetector】
    6).添加编译时的AspectJ；
    7).给BeanFactory中注册一些能用的组件；
       environment【ConfigurableEnvironment】、
       systemProperties【Map<String, Object>】、
       systemEnvironment【Map<String, Object>】
4。postProcessBeanFactory(beanFactory);BeanFactory准备工作完成后进行的后置处理工作；
    1).子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置
==============================以上BeanFactory的创建及预准备工作============================================
5。invokeBeanFactoryPostProcessors(beanFactory)；执行BeanFactoryPostProcessor的方法；
    BeanFactoryPostProcessor：BeanFactory的后置处理器。在BeanFactory标准初始化之后执行的；
    两个接口BeanFactoryPostProcessor，BeanDefinitionRegistryPostProcessor
    1).执行BeanFactoryPostProcessor的方法：
         1).获取所有的BeanDefinitionRegistryPostProcessor；
         2).先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor
            postProcessor.postProcessBeanDefinitionRegistry(registry);
         3).再执行实现了Ordered接口顺序接口的BeanDefinitionRegistryPostProcessor
            postProcessor.postProcessBeanDefinitionRegistry(registry);
         4).最后执行没有实现任何优先级或者顺序接口的BeanDefinitionRegistryPostProcessor；
            postProcessor.postProcessBeanDefinitionRegistry(registry);

         在执行BeanFactoryPostProcessor的方法
          1).获取所有的BeanDefinitionRegistryPostProcessor；
          2).先执行实现了PriorityOrdered优先级接口的BeanDefinitionRegistryPostProcessor
             postProcessor.postProcessBeanDefinitionRegistry(registry);
          3).再执行实现了Ordered接口顺序接口的BeanDefinitionRegistryPostProcessor
             postProcessor.postProcessBeanDefinitionRegistry(registry);
          4).最后执行没有实现任何优先级或者顺序接口的BeanDefinitionRegistryPostProcessor；
             postProcessor.postProcessBeanDefinitionRegistry(registry);
6。registerBeanPostProcessors(beanFactory);注册BeanPostProcessors(bean的后置处理器)【intercept bean creation】
    不同接口类型的BeanPostProcessor，在bean创建前后的执行时机是不一样的
    DestructionAwareBeanPostProcessor、
    InstantiationAwareBeanPostProcessor、
    SmartInstantiationAwareBeanPostProcessor、
    MergedBeanDefinitionPostProcessor【internalPostProcessors】
    1).获取所有的BeanPostProcessor；后置处理器都默认可以通过PriorityOrdered,Ordered接口来执行优先级
    2).先注册PriorityOrdered优先级接口的BeanPostProcessor；
       先把每一个BeanPostProcessor；添加到beanFactory中
	   beanFactory.addBeanPostProcessor(postProcessor);
	3).在注册Ordered接口的
	4).最后注册没有实现任何优先级接口的
	5).最终注册MergedBeanDefinitionPostProcessor
	6).注册一个ApplicationListenerDetector；来在bean创建完成后检查是否是ApplicationListener，如果是
	   applicationContext.addApplicationListener((ApplicationListener<?>) bean)
7。initMessageSource();初始化MessageSource组件(做国际化功能；消息绑定，消息解析)，初始化消息源；
    1).getBeanFactory();
    2).看容器中是否有id为messageSource的，类型是MessageSource的组件
       如果有赋值给messageSource，如果没有自己创建一个DelegatingMessageSource；
           MessageSource，取出国际化配置文件中的某个key的值，能按照区域信息获取
    3).把创建好的MessageSource注册在容器中，以后获取国际化配置文件的值的时候，可以自动注入MessageSource
       beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);
	   String getMessage(String code, @Nullable Object[] args, @Nullable String defaultMessage, Locale locale);
8。initApplicationEventMulticaster();初始化事件派发器
    1).getBeanFactory();
    2).从beanFactory中获取applicationEventMulticaster的ApplicationEventMulticaster；
    3).如果上一步没有配置，则创建一个SimpleApplicationEventMulticaster
    4).将创建的ApplicationEventMulticaster添加到BeanFactory中，以后其他组件直接自动注入
9。onRefresh();留给字容器(子类)
    1).子类重写这个方法，在容器刷新的时候可以自定义逻辑
10。registerListeners();给容器中将所有项目里的ApplicationListener注册进来
    1).从容器中拿到所有的ApplicationListener组件，getApplicationListeners()；
    2).将每个监听器添加到事件派发器中
       getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);
    3).派发早期(步骤之前)的事件
11。finishBeanFactoryInitialization(beanFactory);初始化所有剩下单实例bean；
    1).beanFactory.preInstantiateSingletons();实例话剩下的单实例bean；
         1.获取容器中的所有bean，依次进行初始化和创建对象
         2.获取bean的定义信息，RootBeanDefinition
         3.bean不是抽象的，是单例的，是懒加载的
              1.判断是否是FactoryBean；是否是实现FactoryBean接口的bean；
              2.不是工厂bean，用getBean()创建
                  0.getBean(beanName); ioc.getBean();
                  1.doGetBean(name, null, null, false);
                  2.先获取缓存中保存的单实例bean，如果能获取到说明这个bean之前被创建过(所有创建过的单实例bean都会被缓存起来)
                    	private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);
                  3.缓存中获取不到，开始bean的创建对象流程
                  4.标记当前bean已经被创建(防止多线程重复创建)
                  5.获取bean的定义信息
                  6.获取当前bean依赖的其他bean；如果有按照getBean()把依赖先创建出来
                  7.启动单实例bean的创建流程:
                        1.createBean(beanName, mbd, args);
                        2.
